type: edu
files:
  - name: app.py
    visible: true
    text: |
      from flask import Flask
      import sys
      
      app = Flask(__name__)
      
      # write your code here
      
      # don't change the following way to run flask:
      if __name__ == '__main__':
          if len(sys.argv) > 1:
              arg_host, arg_port = sys.argv[1].split(':')
              app.run(host=arg_host, port=arg_port)
          else:
              app.run()
    learner_created: false
  - name: test/__init__.py
    visible: false
    learner_created: false
  - name: test/tests.py
    visible: false
    text: "import asyncio\nimport copy\nimport os\nimport sqlite3\n\nfrom hstest import\
    \ FlaskTest, CheckResult, WrongAnswer\nfrom hstest import dynamic_test\nfrom hstest.dynamic.security.exit_handler\
    \ import ExitHandler\nimport xml.etree.ElementTree as ET\nimport json\nfrom pip._vendor\
    \ import requests\n\nclass Ingredient:\n    title: str\n    amount: float\n  \
    \  measure: str\n    def __eq__(self, other):\n        if isinstance(other, Ingredient)\
    \ == False:\n            return False\n        if self.title != other.title or\
    \ self.amount != other.amount or self.measure != other.measure:\n            return\
    \ False\n        else:\n            return True\nclass Recipe_info:\n    title\
    \ = ''\n    ingredients = []\n    directions = []\n    description = ''\n\n  \
    \  def __lt__(self, other):\n        return self.title < other.title\n\n    def\
    \ __init__(self, recipe=None, ingredients=None):\n        if recipe is None:\n\
    \            return\n        if isinstance(recipe, str):\n            recipe_json\
    \ = json.loads(recipe)\n            self.title = recipe_json['title']\n      \
    \      for direction in recipe_json['directions']:\n                self.directions.append(direction)\n\
    \            self.description = recipe_json['description']\n            self.ingredients\
    \ = []\n            for ingredient in recipe_json['ingredients']:\n          \
    \      i = Ingredient()\n                i.title = ingredient['title']\n     \
    \           i.amount = ingredient['amount']\n                i.measure = ingredient['measure']\n\
    \                self.ingredients.append(i)\n        elif isinstance(recipe, Recipe_info):\n\
    \            copy_other = copy.deepcopy(recipe)\n            self.title = copy_other.title\n\
    \            self.directions = copy_other.directions\n            self.ingredients\
    \ = copy_other.ingredients\n        elif isinstance(recipe, dict):\n         \
    \   self.__init__(json.dumps(recipe))\n\n\n    def __eq__(self, other):\n    \
    \    if not isinstance(other, Recipe_info) and not isinstance(other, Recipe_info_with_id):\n\
    \            return False\n        if self.title != other.title:\n           \
    \ return False\n        if len(self.directions) != len(other.directions):\n  \
    \          return False\n        for direction in self.directions:\n         \
    \   if direction not in other.directions:\n                return False\n    \
    \    if len(self.ingredients) != len(other.ingredients):\n            return False\n\
    \        for ingredient1 in self.ingredients:\n            flag = True\n     \
    \       for ingredient2 in other.ingredients:\n                if ingredient1.title\
    \ == ingredient2.title and ingredient1.measure == ingredient2.measure and ingredient1.amount\
    \ == ingredient2.amount:\n                    flag = False\n                 \
    \   break\n            if flag:\n                return False\n        return\
    \ True\n\n    def to_json(self):\n        recipe_dict = copy.deepcopy(self).__dict__\n\
    \        recipe_dict['ingredient'] = []\n        for ingredient in self.ingredients:\n\
    \            ingredient.amount = float(ingredient.amount)\n            recipe_dict['ingredient'].append((ingredient.__dict__))\n\
    \        del recipe_dict['ingredients']\n        recipe_dict['ingredients'] =\
    \ recipe_dict.pop('ingredient')\n        jsonStr = json.dumps(recipe_dict)\n \
    \       return jsonStr\n\n    def to_json_with_id(self, id):\n        recipe_dict\
    \ = copy.deepcopy(self).__dict__\n        recipe_dict['ingredient'] = []\n   \
    \     for ingredient in self.ingredients:\n            ingredient.amount = float(ingredient.amount)\n\
    \            recipe_dict['ingredient'].append((ingredient.__dict__))\n       \
    \ del recipe_dict['ingredients']\n        recipe_dict['id'] = id\n        recipe_dict['ingredients']\
    \ = recipe_dict.pop('ingredient')\n        jsonStr = json.dumps(recipe_dict)\n\
    \        return jsonStr\n    def __str__(self):\n        return self.to_json()\n\
    \    def get_ingredients_url_parameters(self):\n        return \"|\".join([ingredient.title\
    \ for ingredient in self.ingredients])\n\nclass Recipe_info_with_id(Recipe_info)\
    \ :\n    id: int\n    def __str__(self, without_id=True):\n        if without_id:\n\
    \            return self.to_json_without_id()\n        else:\n            return\
    \ super.__str__()\n    def from_other_recipe(self, recipe):\n        copy_other\
    \ = copy.deepcopy(recipe)\n        self.title = copy_other.title\n        self.directions\
    \ = copy_other.directions\n        self.ingredients = copy_other.ingredients\n\
    \        self.description = copy_other.description\n    def from_json(self, recipe:\
    \ str):\n        recipe_json = json.loads(recipe)\n        self.title = recipe_json['title']\n\
    \        self.directions = recipe_json['directions']\n        self.ingredients\
    \ = []\n        for ingredient in recipe_json['ingredients']:\n            i =\
    \ Ingredient()\n            i.title = ingredient['title']\n            i.amount\
    \ = ingredient['amount']\n            i.measure = ingredient['measure']\n    \
    \        self.ingredients.append(i)\n    def __init__(self, other=None, id=None):\n\
    \        if other is None:\n            return\n        if isinstance(other, Recipe_info):\n\
    \            self.from_other_recipe(other)\n            self.id = id\n       \
    \ if isinstance(other, Recipe_info_with_id):\n            self.from_other_recipe(other)\n\
    \            self.id = other.id\n            if id is not None:\n            \
    \    self.id = id\n        elif isinstance(other, str):\n            recipe_json\
    \ = json.loads(other)\n            self.from_json(other)\n            try:\n \
    \               self.id = recipe_json['id']\n            except:\n           \
    \     if id is not None:\n                    self.id = id\n\n    def to_json(self):\n\
    \        recipe_dict = copy.deepcopy(self).__dict__\n        recipe_dict['ingredient']\
    \ = []\n        for ingredient in self.ingredients:\n            ingredient.amount\
    \ = float(ingredient.amount)\n            recipe_dict['ingredient'].append((ingredient.__dict__))\n\
    \        del recipe_dict['ingredients']\n        recipe_dict['ingredients'] =\
    \ recipe_dict.pop('ingredient')\n        jsonStr = json.dumps(recipe_dict)\n \
    \       return jsonStr\n    def to_json_without_id(self):\n        recipe_dict\
    \ = copy.deepcopy(self).__dict__\n        recipe_dict['ingredient'] = []\n   \
    \     for ingredient in self.ingredients:\n            ingredient.amount = float(ingredient.amount)\n\
    \            recipe_dict['ingredient'].append((ingredient.__dict__))\n       \
    \ del recipe_dict['ingredients']\n        del recipe_dict['id']\n        recipe_dict['ingredients']\
    \ = recipe_dict.pop('ingredient')\n        jsonStr = json.dumps(recipe_dict)\n\
    \        return jsonStr\n    def get_ingredients_url_parameters(self):\n     \
    \   return \"|\".join([ingredient.title for ingredient in self.ingredients])\n\
    \n\ndef recipes_from_xml():\n    list_recipes = []\n    root_el = ET.fromstring('<recipes><recipe\
    \ title=\"All-Day-Long Crockpot Beef\" description=\"Instead of having to be in\
    \ the kitchen for hours, why not try this easy crockpot recipe that will help\
    \ you create a succulent dinner without spending hours in the kitchen.\"><ingredients><ingredient\
    \ amount=\"907.2\" measure=\"g\">beef</ingredient><ingredient amount=\"10\" measure=\"\
    ml\">black pepper</ingredient><ingredient amount=\"2\" measure=\"each\">garlic</ingredient><ingredient\
    \ amount=\"2\" measure=\"each\">onion soup mix</ingredient><ingredient amount=\"\
    10\" measure=\"ml\">worcestershire sauce</ingredient><ingredient amount=\"5\"\
    \ measure=\"ml\">steak sauce</ingredient><ingredient amount=\"3\" measure=\"each\"\
    >carrots</ingredient><ingredient amount=\"2\" measure=\"each\">celery</ingredient><ingredient\
    \ amount=\"1\" measure=\"each\">sweet red bell peppers</ingredient><ingredient\
    \ amount=\"1\" measure=\"each\">onions</ingredient><ingredient amount=\"118\"\
    \ measure=\"ml\">water</ingredient><ingredient amount=\"118\" measure=\"ml\">tomato\
    \ juice</ingredient></ingredients><directions><direction>Cut beef roast into serving-sized\
    \ portions.</direction><direction>Use more beef if you need more than 6 servings.</direction><direction>Brown\
    \ beef in a bit of vegetable oil, although you can skip this step if rushed for\
    \ time.</direction><direction>Slice onion and separate into rings.</direction><direction>Dice\
    \ the peeled carrots, dice the celery and slice the peppers into thin strips or\
    \ circles.</direction><direction>Place these into bottom of crockpot.</direction><direction>Sprinkle\
    \ the beef pieces with fresh ground black pepper, minced garlic and the onion\
    \ soup mix.</direction><direction>Place on top of the vegetables.</direction><direction>Mix\
    \ the steak sauce and worcestershire sauce in a small</direction><direction>Pour\
    \ this over the meat.</direction><direction>Turn the crockpot to High for 30 minutes,\
    \ or, if you\\'re in a hurry, skip this step.</direction><direction>Turn to Low,\
    \ cover and cook for 7 to 9 hours.</direction><direction>Keep the crockpot covered\
    \ as much as possible throughout cooking time.</direction><direction>A crockpot\
    \ can be used to cook this type of meal for a varied amount of time, depending\
    \ on your schedule.  It is not important that you take the meat and vegetables\
    \ out at a specific amount of time.  One or two hours either way usually makes\
    \ no difference.</direction><direction>When ready to serve, dip meat and vegetables\
    \ out of pot with a slotted spoon.  Use the liquid as is or turn crockpot to High\
    \ and thicken liquid with a little</direction></directions></recipe><recipe title=\"\
    All-Day-Long Potato Soup\" description=\"Easy crock pot potato soup. Serve with\
    \ chopped green onions and slice cheddar cheese. SUPERB! Absolutely wonderful.\"\
    ><ingredients><ingredient amount=\"680.4\" measure=\"g\">potatoes</ingredient><ingredient\
    \ amount=\"1\" measure=\"each\">onions</ingredient><ingredient amount=\"15\" measure=\"\
    ml\">butter</ingredient><ingredient amount=\"1\" measure=\"each\">vegetable stock\
    \ cubes</ingredient><ingredient amount=\"15\" measure=\"ml\">parsley leaves</ingredient><ingredient\
    \ amount=\"710\" measure=\"ml\">water</ingredient><ingredient amount=\"237\" measure=\"\
    ml\">milk</ingredient><ingredient amount=\"59\" measure=\"ml\">all-purpose flour</ingredient></ingredients><directions><direction>Place\
    \ the first six ingredients in your slow cooker and cook all day on the low setting.</direction><direction>About\
    \ &#189;  to one hour before serving; add milk and</direction><direction>Once\
    \ the soup starts to thicken, it is ready to serve.</direction><direction>This\
    \ simple slow cooker potato soup from scratch is a mainstay in our family.  We\
    \ frequently vary the recipe as follows:</direction><direction>Stir in &#188;\
    \ pound (125 g) of shredded cheese just prior to serving for cheese potato soup.\
    \ A can of evaporated milk may be substituted for the regular milk.</direction><direction>When\
    \ serving, top with crispy</direction><direction>Combine cheese and bacon as noted\
    \ in both variations above.</direction></directions></recipe><recipe title=\"\
    Good As Gold Chicken (Like Kfc\\'s and Boston\\'s)\" description=\"If you\\'re\
    \ family loves chicken, they will simply enjoy eating this scrumptious dish!\"\
    ><ingredients><ingredient amount=\"59\" measure=\"ml\">vegetable oil</ingredient><ingredient\
    \ amount=\"15\" measure=\"ml\">honey</ingredient><ingredient amount=\"15\" measure=\"\
    ml\">lime juice</ingredient><ingredient amount=\"1.3\" measure=\"ml\">paprika</ingredient><ingredient\
    \ amount=\"1\" measure=\"x\">seasoned salt</ingredient><ingredient amount=\"4\"\
    \ measure=\"each\">chicken breasts</ingredient></ingredients><directions><direction>Mix\
    \ ingredients (except chicken) in a saucepan and warm just to melt honey.</direction><direction>Arrange\
    \ chicken breast-side-up in a square</direction><direction>Bake uncovered at 400\
    \ degrees about 35 to 40 minutes.</direction><direction>Basting pieces without\
    \ turning them, 3 or 4 times during baking.</direction><direction>Immediately\
    \ upon removing from oven, seal baking dish or pan tightly in foil and let stand\
    \ 15 to 20 minutes before serving.</direction></directions></recipe><recipe title=\\\
    \"100% Parmesan Chicken\\\" description=\\\"Add some cheese to your succulent\
    \ chicken with this delicious recipe that uses parmesan cheese and a variety of\
    \ spices.\\\"><ingredients><ingredient amount=\\\"6\\\" measure=\\\"each\\\">chicken\
    \ breasts</ingredient><ingredient amount=\\\"30\\\" measure=\"ml\">butter</ingredient><ingredient\
    \ amount=\"118\" measure=\"ml\">Parmesan cheese</ingredient><ingredient amount=\"\
    59\" measure=\"ml\">bread crumbs</ingredient><ingredient amount=\"5\" measure=\"\
    ml\">oregano</ingredient><ingredient amount=\"5\" measure=\"ml\">parsley flakes</ingredient><ingredient\
    \ amount=\"1.3\" measure=\"ml\">paprika</ingredient><ingredient amount=\"1.3\"\
    \ measure=\"ml\">salt</ingredient><ingredient amount=\"1.3\" measure=\"ml\">black\
    \ pepper</ingredient></ingredients><directions><direction>Heat</direction><direction>Dip\
    \ chicken in margarine; coat with combined remaining ingredients. Place in prepared\
    \ pan. Bake 20 to 25 minutes or until tender.</direction><direction>Substitute\
    \ &#8539; to &#188; teaspoon ground red pepper for black pepper.</direction></directions></recipe><recipe\
    \ title=\"10 Minute Sichuan/Szechuan Chicken\" description=\"Quick, easy and tasty.\
    \  Why order out for Chinese when it\\'s so easy to make at home.  Low in fat\
    \ only 223 calories per serving with great flavor. If you are quick you can have\
    \ it ready in only 10 minutes, 15 minutes at the most!\"><ingredients><ingredient\
    \ amount=\"4\" measure=\"each\">chicken breasts</ingredient><ingredient amount=\"\
    23\" measure=\"ml\">vinegar</ingredient><ingredient amount=\"45\" measure=\"ml\"\
    >cornstarch</ingredient><ingredient amount=\"5\" measure=\"ml\">sugar</ingredient><ingredient\
    \ amount=\"15\" measure=\"ml\">vegetable oil</ingredient><ingredient amount=\"\
    59\" measure=\"ml\">water</ingredient><ingredient amount=\"3\" measure=\"cloves\"\
    >garlic</ingredient><ingredient amount=\"6\" measure=\"each\">scallions, spring\
    \ or green onions</ingredient><ingredient amount=\"75\" measure=\"ml\">soy sauce,\
    \ tamari</ingredient><ingredient amount=\"0.6\" measure=\"ml\">cayenne pepper</ingredient></ingredients><directions><direction>Cut\
    \ chicken into cubes.</direction><direction>Lightly toss with cornstarch in bag\
    \ to coat.</direction><direction>Heat oil in skillet or wok, medium-high heat.</direction><direction>Stir-fry\
    \ chicken and garlic until lightly browned.</direction><direction>Add soy sauce,\
    \ vinegar, sugar and water.</direction><direction>Cover and cook 3 minutes or\
    \ until chicken is cooked through.</direction><direction>Add green onions and\
    \ cayenne; cook uncovered about 2 minutes longer.</direction></directions></recipe></recipes>')\n\
    \    for recipe_el in root_el:\n        recipe = Recipe_info()\n        recipe.title\
    \ = recipe_el.attrib['title']\n        recipe.description = recipe_el.attrib['description']\n\
    \        recipe.directions = []\n        for direction in recipe_el.find(\"directions\"\
    ):\n            recipe.directions.append(direction.text)\n        ingredients\
    \ = recipe_el.find(\"ingredients\")\n        recipe.ingredients = []\n       \
    \ for ingredient_el in ingredients:\n            ingredient = Ingredient()\n \
    \           ingredient.title = ingredient_el.text\n            ingredient.amount\
    \ = float(ingredient_el.attrib['amount'])\n            ingredient.measure = ingredient_el.attrib['measure']\n\
    \            recipe.ingredients.append(ingredient)\n        list_recipes.append(recipe)\n\
    \    return list_recipes\n\nclass FlaskProjectTest(FlaskTest):\n    source = 'app'\n\
    \    list_recipes = []\n    list_added_recipes = []\n    recipe_name_table = \"\
    \"\n    ingredient_name_table = \"\"\n    wrong_answers = \\\n        [\n    \
    \        \"The database must contain a table with {} (named {} or {})\",#0\n \
    \           \"{} route should return code 200, now code is {}\", #1\n        \
    \    \"{} {} key should be in the json response\", #2\n            \"{} response\
    \ should not be empty\", #3\n            \"{} route should return '{}' if no recipes\
    \ added, now '{}'\", #4\n            \"{} route should return '{}' If not enough\
    \ ingredients, now '{}'\",  # 5\n            \"{} route should return json with\
    \ {} keys, now '{}'\",  # 6\n            \"{} route should return correct json\
    \ response, if recipe added, now response: '{}'\",  # 7\n            \"{} route,\
    \ id added recipe must be a digit\", #8\n            \"{} route, id must not be\
    \ static\", #9\n            \"{} route, should return 404 status code if recipe\
    \ with id={} not added, now status code is {}\",  # 10\n            \"{} route\
    \ should return a list of recipes, according to the list of specified ingredients,\
    \ now number recipes is '{}', but expected '{}'\",  # 11\n            \"{} route,\
    \ {} from recipe should be '{}', now '{}'\",  # 12\n            \"{} route, the\
    \ number of ingredients in the recipe does not correspond to the original, now\
    \ {}, expected {}\",  # 13\n            \"{} route, one of the ingredients of\
    \ the original recipe is not returned, title='{}', measure='{}', amount='{}'\"\
    ,  # 14\n            \"{} route should return {} status code, if no recipe with\
    \ specified id, now status code is '{}'\",  # 15\n            \"{} route should\
    \ delete recipe and return {} status code, if recipe with specified id found,\
    \ now status code is '{}'\",  # 16\n            \"{} route, 'directions' from\
    \ json recipe must be a list \",  # 17\n            \"{}' route should update\
    \ recipe and return 204 if recipe with id {} exists, now status code is {}\",\
    \ #18\n            \"{}' route, invalid json response: {}\", #19\n           \
    \ \"{}' route should return '[]' If there are no prescriptions that meet the restrictions,\
    \ now response '{}'\", #20\n            \"{}' route, another recipe was expected,\
    \ number directions not checked\", #21\n            \"Since the recipe(s) have\
    \ already been added to the system, the output format should be a list of recipes\
    \ []\", #22\n            \"{} route should return a list of recipes in json format,\
    \ now the route returns a list of strings. Look at example #5\", # 23\n      \
    \      \"{} route should return a list of recipes in the correct format. See example\
    \ #5\",  # 24\n            \"{}, {} key should not be in the json response\",\
    \  # 25\n        ]\n    connection_error = \"Could not establish a {} connection\
    \ to {}.\"\n    links = \\\n    [\n        \"{}api/recipe\", #0\n        \"{}api/recipe?ingredients={}\"\
    , #1\n        \"{}api/recipe/new\", #2\n        \"{}api/recipe/{}\",  # 3\n  \
    \      \"{}api/recipe?ingredients={}&max_directions={}\",  # 4\n    ]\n    strings\
    \ = \\\n    [\n        \"No recipe here yet\", #0\n    ]\n    json_responses =\
    \ \\\n        [\n            {\"error\": strings[0]},\n            []\n      \
    \  ]\n\n    def my_init(self):\n        self.list_recipes = recipes_from_xml()\n\
    \n    def __init__(self, source_name: str = ''):\n        super().__init__(source_name)\n\
    \        self.my_init()\n    def check_exist_table(self, table_name:str):\n  \
    \      con = sqlite3.connect('recipes.db')\n        cursor = con.cursor()\n  \
    \      sql_query = \"\"\"SELECT count(name) FROM sqlite_master  \n           \
    \       WHERE type='table' and name='{}';\"\"\"\n        cursor.execute(sql_query.format(table_name))\n\
    \        res = cursor.fetchall()\n        if res[0][0] == 1:\n            con.close()\n\
    \            return True\n        else:\n            con.close()\n           \
    \ return False\n    def check_table_columns(self, table_name, list_columns):\n\
    \        con = sqlite3.connect('recipes.db')\n        cursor = con.cursor()\n\
    \        sql_query = \"SELECT name FROM PRAGMA_TABLE_INFO('{}')\"\n        cursor.execute(sql_query.format(table_name))\n\
    \        res = cursor.fetchall()\n        list_column_names = []\n        for\
    \ tuple in res:\n            name = tuple[0]\n            list_column_names.append(name)\n\
    \        for name in list_columns:\n            if name not in list_column_names:\n\
    \                raise WrongAnswer(f\"Table '{table_name}' must contain a column\
    \ named '{name}'\")\n\n    async def test_database_structure(self):\n        if\
    \ not os.path.exists(\"recipes.db\"):\n            raise WrongAnswer(\"Strange,\
    \ the database file is not involved. You may not have named the database correctly\
    \ (recipes.db).\")\n        #check data base structure\n        if self.check_exist_table(\"\
    recipe\"):\n            self.recipe_name_table = \"recipe\"\n        elif self.check_exist_table(\"\
    recipes\"):\n            self.recipe_name_table = \"recipes\"\n        else:\n\
    \            raise WrongAnswer(self.wrong_answers[0].format(\"recipes\", \"recipe\"\
    , \"recipes\"))\n        if self.check_exist_table(\"ingredient\"):\n        \
    \    self.ingredient_name_table = \"ingredient\"\n        elif self.check_exist_table(\"\
    ingredients\"):\n            self.ingredient_name_table = \"ingredients\"\n  \
    \      else:\n            raise WrongAnswer(self.wrong_answers[0].format(\"ingredients\"\
    , \"ingredient\", \"ingredients\"))\n        #table columns\n        self.check_table_columns(self.recipe_name_table,\
    \ ['id', 'title', 'description'])\n        self.check_table_columns(self.ingredient_name_table,\
    \ ['id', 'title', 'measure', 'amount'])\n        await self.check_data_base(self.list_added_recipes)\n\
    \n    def check_recipes_str(self, recipes:list, content:str, recipe_added, enough_ingredients):\n\
    \        try:\n            recipes_dict = json.loads(content)\n        except:\n\
    \            raise WrongAnswer(self.wrong_answers[7].format(self.links[1].format(\"\
    GET /\", \"...\"), content))\n        if recipe_added and enough_ingredients:\n\
    \            if not content:\n                raise WrongAnswer(self.wrong_answers[3].format(self.links[1].format(\"\
    GET /\", \"...\")))\n            if len(recipes) != len(recipes_dict):\n     \
    \           raise WrongAnswer(self.wrong_answers[11].format(self.links[1].format(\"\
    GET /\", \"...\"), len(recipes_dict), len(recipes),))\n            if type(recipes_dict)\
    \ != list:\n                raise WrongAnswer(self.wrong_answers[22])\n      \
    \      for recipe in recipes_dict:\n                if type(recipe) == str:\n\
    \                    raise WrongAnswer(self.wrong_answers[23].format(self.links[1].format(\"\
    GET /\", \"...\")))\n                if type(recipe) != dict:\n              \
    \      raise WrongAnswer(self.wrong_answers[24].format(self.links[1].format(\"\
    GET /\", \"...\")))\n                if \"title\" not in recipe.keys():\n    \
    \                raise WrongAnswer(self.wrong_answers[2].format(self.links[1].format(\"\
    GET /\", \"...\"), \"'title'\"))\n                if \"directions\" not in recipe.keys():\n\
    \                    raise WrongAnswer(self.wrong_answers[2].format(self.links[1].format(\"\
    GET /\", \"...\"), \"'directions'\"))\n                if \"ingredients\" not\
    \ in recipe.keys():\n                    raise WrongAnswer(self.wrong_answers[2].format(self.links[1].format(\"\
    GET /\", \"...\"), \"ingredients\"))\n                if \"id\" not in recipe.keys():\n\
    \                    raise WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"\
    GET /\", \"id\"), \"id\"))\n                if not \"description\" in recipe.keys():\n\
    \                    raise WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"\
    GET /\", \"id\"), \"'description'\"))\n                if not isinstance(recipe['directions'],\
    \ list):\n                    raise WrongAnswer(self.wrong_answers[17].format(self.links[3].format(\"\
    GET /\", \"id\")))\n                if len(recipe.keys()) > 5:\n             \
    \       raise WrongAnswer(\n                        self.wrong_answers[6].format(self.links[1].format(\"\
    GET /\", \"...\"), 5, len(recipe.keys())))\n        elif recipe_added == False:\n\
    \            if recipes_dict != self.json_responses[0]:\n                raise\
    \ WrongAnswer(self.wrong_answers[4].format(self.links[1].format(\"GET /\", \"\
    ...\"), str(self.json_responses[0]), content))\n        elif recipe_added and\
    \ not enough_ingredients:\n            if recipes_dict != self.json_responses[1]:\n\
    \                raise WrongAnswer(self.wrong_answers[5].format(self.links[1].format(\"\
    GET /\", \"...\"), str(self.json_responses[1]), content))\n\n    async def test_get_recipe_by_ingredients(self,\
    \ recipes: list, recipe_added=True, enough_ingredients=True):\n        try:\n\
    \            r = requests.get(self.links[1].format(self.get_url(), recipes[0].get_ingredients_url_parameters()))\n\
    \        except requests.exceptions.ConnectionError as e:\n            raise WrongAnswer(self.connection_error.format(e.request.method,\
    \ e.request.url.split('?')[0]))\n        if r.status_code != 200:\n          \
    \  raise WrongAnswer(self.wrong_answers[1].format(self.links[1].format(\"GET /\"\
    , \"...\"), r.status_code))\n        content = r.content.decode('UTF-8')\n   \
    \     self.check_recipes_str(recipes, content, recipe_added, enough_ingredients)\n\
    \n    async def test_get_recipe_by_ingredients_max_directions(self, recipe: Recipe_info,\
    \ max_directions=0, exists_result=False):\n        try:\n            r = requests.get(self.links[4].format(self.get_url(),\
    \ recipe.get_ingredients_url_parameters(), max_directions))\n        except requests.exceptions.ConnectionError\
    \ as e:\n            raise WrongAnswer(self.connection_error.format(e.request.method,\
    \ e.request.url.split('?')[0]))\n        if r.status_code != 200:\n          \
    \  raise WrongAnswer(self.wrong_answers[1].format(self.links[1].format(\"GET /\"\
    , \"...\"), r.status_code))\n        content = r.content.decode('UTF-8')\n   \
    \     try:\n            dict_result = json.loads(content)\n        except:\n \
    \           raise WrongAnswer(self.wrong_answers[19].format(self.links[4].format(\"\
    GET /\", \"...\",\"...\"), content))\n        if not exists_result:\n        \
    \    if len(dict_result) != 0:\n                raise WrongAnswer(self.wrong_answers[20].format(self.links[4].format(\"\
    GET /\", \"...\",\"...\"), content))\n        else:\n            recipe_from_db\
    \ = Recipe_info(dict_result[0])\n            if len(recipe_from_db.directions)\
    \ > max_directions:\n                raise WrongAnswer(self.wrong_answers[20].format(self.links[4].format(\"\
    GET /\", \"...\",\"...\")))\n\n    async def test_sorting(self):\n        ingredients\
    \ = '|'.join([recipe.get_ingredients_url_parameters() for recipe in self.list_added_recipes])\n\
    \        try:\n            r = requests.get(self.links[1].format(self.get_url(),\
    \ ingredients))\n        except requests.exceptions.ConnectionError as e:\n  \
    \          raise WrongAnswer(self.connection_error.format(e.request.method, e.request.url.split('?')[0]))\n\
    \        if r.status_code != 200:\n            raise WrongAnswer(self.wrong_answers[1].format(self.links[1].format(\"\
    GET /\", \"...\"), r.status_code))\n        content = r.content.decode(\"UTF-8\"\
    )\n        recipes_list_dict = None\n        try:\n            recipes_list_dict\
    \ = json.loads(content)\n        except:\n            raise WrongAnswer(\"Error\
    \ converting received response to json object\")\n        list_recipes = []\n\
    \        for json_recipe in recipes_list_dict:\n            list_recipes.append(Recipe_info(json_recipe))\n\
    \        sorted_list = []\n        for r in list_recipes:\n            sorted_list.append(r)\n\
    \        sorted_list.sort(reverse = True)\n        for i in range(len(list_recipes)):\n\
    \            if sorted_list[i]!=list_recipes[i]:\n                raise WrongAnswer(self.links[1].format(\"\
    GET /\", \"...\")+\", improperly sorted recipes\");\n    def check_recipe_str_get_by_id(self,\
    \ recipe: Recipe_info, content: str, id:int):\n        try:\n            recipe_dict\
    \ = json.loads(content)\n        except:\n            raise WrongAnswer(self.wrong_answers[7].format(self.links[3].format(\"\
    GET /\", id), content))\n        if not content:\n            raise WrongAnswer(self.wrong_answers[3].format(self.links[3].format(\"\
    GET /\", id)))\n        if \"title\" not in recipe_dict.keys():\n            raise\
    \ WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"GET /\", id),\
    \ \"'title'\"))\n        if \"directions\" not in recipe_dict.keys():\n      \
    \      raise WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"\
    GET /\", id), \"'directions'\"))\n        if \"ingredients\" not in recipe_dict.keys():\n\
    \            raise WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"\
    GET /\", id), \"'ingredients'\"))\n        if \"description\" not in recipe_dict.keys():\n\
    \            raise WrongAnswer(self.wrong_answers[2].format(self.links[3].format(\"\
    GET /\", id), \"'description'\"))\n        if not isinstance(recipe_dict['directions'],\
    \ list):\n            raise WrongAnswer(self.wrong_answers[17].format(self.links[3].format(\"\
    GET /\", id)))\n        if \"id\" in recipe_dict.keys():\n            raise WrongAnswer(self.wrong_answers[25].format(self.links[3].format(\"\
    GET /\", id), \"'id'\"))\n        if len(recipe_dict.keys()) > 4:\n          \
    \  raise WrongAnswer(\n                self.wrong_answers[6].format(self.links[3].format(\"\
    GET /\", id), 4, len(recipe_dict.keys())))\n        if recipe.title != recipe_dict['title']:\n\
    \            raise WrongAnswer(self.wrong_answers[12].format(self.links[3].format(\"\
    GET /\", id), 'title', recipe.title, recipe_dict['title']))\n        if recipe.directions\
    \ != recipe_dict['directions']:\n            raise WrongAnswer(self.wrong_answers[12].format(self.links[3].format(\"\
    GET /\", id), 'directions', recipe.directions, recipe_dict['directions']))\n \
    \       link = self.links[3].format(\"GET /\", id)\n        try:\n           \
    \ if len(recipe.ingredients) != len(recipe_dict['ingredients']):\n           \
    \     raise WrongAnswer(self.wrong_answers[13].format(link, len(recipe_dict['ingredient']),\
    \ len(recipe.ingredients)))\n        except KeyError:\n            raise WrongAnswer(\"\
    Make sure you added all the ingredients\")\n        self.check_ingredients(recipe.ingredients,\
    \ recipe_dict['ingredients'], id)\n    def check_ingredients(self, recipe_ingredients:list,\
    \ json_ingredients:list, id):\n        for ingredient_recipe in recipe_ingredients:\n\
    \            flag_exists = False\n            for ingredient_json in json_ingredients:\n\
    \                if ingredient_json['title'] == ingredient_recipe.title\\\n  \
    \                      and ingredient_json['measure'] == ingredient_recipe.measure\\\
    \n                        and str(ingredient_json['amount']) == str(ingredient_recipe.amount):\n\
    \                    flag_exists = True\n                    break\n         \
    \   if not flag_exists:\n                raise WrongAnswer(self.wrong_answers[14].format(self.links[3].format(\"\
    GET /\", id), ingredient_recipe.title, ingredient_recipe.measure, ingredient_recipe.amount))\n\
    \n    async def test_del_recipe_by_id(self, id:int, recipe_added=False, recipe:\
    \ Recipe_info=None):\n        try:\n            r = requests.delete(self.links[3].format(self.get_url(),\
    \ id))\n        except requests.exceptions.ConnectionError as e:\n           \
    \ raise WrongAnswer(self.connection_error.format(e.request.method, e.request.url.split('?')[0]))\n\
    \        if not recipe_added:\n            if r.status_code != 404:\n        \
    \        raise WrongAnswer(self.wrong_answers[15].format(self.links[3].format(\"\
    DELETE /\", id), 404, r.status_code))\n        else:\n            if r.status_code\
    \ != 204:\n                raise WrongAnswer(self.wrong_answers[16].format(self.links[3].format(\"\
    DELETE /\", id), 204, r.status_code))\n            else:\n                for\
    \ recipe in self.list_added_recipes:\n                    if recipe.id == id:\n\
    \                        self.list_added_recipes.remove(recipe)\n            \
    \            break\n    async def test_get_recipe_by_id(self, id:int, recipe_added=False,\
    \ recipe: Recipe_info=None):\n        try:\n            r = requests.get(self.links[3].format(self.get_url(),\
    \ id))\n        except requests.exceptions.ConnectionError as e:\n           \
    \ raise WrongAnswer(self.connection_error.format(e.request.method, e.request.url.split('?')[0]))\n\
    \        if not recipe_added:\n            if r.status_code != 404:\n        \
    \        raise WrongAnswer(self.wrong_answers[10].format(self.links[3].format(self.get_url(),\
    \ id), id, r.status_code))\n        else:\n            content = r.content.decode(\"\
    UTF-8\")\n            self.check_recipe_str_get_by_id(recipe, content, id)\n \
    \   def check_post_recipe_respond(self, content):\n        if not content:\n \
    \           raise WrongAnswer(self.wrong_answers[7].format(self.links[2].format(\"\
    POST /\", ), content))\n        try:\n            json_dict = json.loads(content)\n\
    \        except:\n            raise WrongAnswer(self.wrong_answers[7].format(self.links[2].format(\"\
    POST /\"), content))\n        if \"id\" not in json_dict.keys():\n           \
    \ raise WrongAnswer(self.wrong_answers[2].format(self.links[2].format(\"POST /\"\
    ), \"id\"))\n        if len(json_dict.keys()) > 1:\n            raise WrongAnswer(self.wrong_answers[6].format(self.links[1].format(\"\
    GET /\", \"...\"), len(json_dict.keys())))\n        if not str(json_dict['id']).isdigit()\
    \ and str(int(json_dict['id'])) == str(json_dict['id']):\n            raise WrongAnswer(self.wrong_answers[8].format(self.links[2].format(\"\
    POST /\")))\n        if len(self.list_recipes) != 0:\n            for recipe in\
    \ self.list_added_recipes:\n                if recipe.id == int(json_dict['id']):\n\
    \                    raise WrongAnswer(self.wrong_answers[9].format(self.links[2].format(\"\
    POST /\")))\n\n    async def check_data_base(self, list_recipes):\n        con\
    \ = sqlite3.connect('recipes.db')\n        cursor = con.cursor()\n        sql_query\
    \ = \"\"\"SELECT count(*) FROM {}\"\"\"\n        if len(list_recipes) == 0:\n\
    \            cursor.execute(sql_query.format(self.recipe_name_table))\n      \
    \      res = cursor.fetchall()\n            if res[0][0] != 0:\n             \
    \   con.close()\n                raise WrongAnswer(\n                    \"The\
    \ database should now be empty and should not contain any recipes. Perhaps your\
    \ database is open in another program and the tests cannot remove it\")\n    \
    \        cursor.execute(sql_query.format(self.ingredient_name_table))\n      \
    \      res = cursor.fetchall()\n            if res[0][0] != 0:\n             \
    \   con.close()\n                raise WrongAnswer(\"Now the database should be\
    \ empty and it should not store recipe ingredients\")\n        else:\n       \
    \     cursor.execute(sql_query.format(self.recipe_name_table))\n            res\
    \ = cursor.fetchall()\n            if res[0][0] != len(list_recipes):\n      \
    \          con.close()\n                raise WrongAnswer(\"Now the number of\
    \ recipes is {}, expected {}\".format(res[0][0], len(list_recipes)))\n       \
    \     cursor.execute(sql_query.format(self.ingredient_name_table))\n         \
    \   res = cursor.fetchall()\n            if res[0][0] == 0:\n                con.close()\n\
    \                raise WrongAnswer(\"Recipe ingredients are not stored in the\
    \ database\")\n            sql_query = f\"SELECT * FROM {self.ingredient_name_table};\"\
    \n            cursor.execute(sql_query)\n            res = cursor.fetchall()\n\
    \            list_ingredients = []\n            for tup in res:\n            \
    \    title = tup[1]\n                measure = tup[2]\n                amount\
    \ = tup[3]\n                ing = Ingredient()\n                ing.title = title\n\
    \                ing.amount = amount\n                ing.measure = measure\n\
    \                list_ingredients.append(ing)\n            for i in list_ingredients:\n\
    \                if list_ingredients.count(i) > 1:\n                    con.close()\n\
    \                    raise WrongAnswer(\n                        \"Ingredients\
    \ in the database must be stored in a single copy, duplicates take up a lot of\
    \ space. The ingredients are now kept in multiple copies\")\n            for r\
    \ in list_recipes:\n                for ingredient in r.ingredients:\n       \
    \             if ingredient not in list_ingredients:\n                       \
    \ con.close()\n                        raise WrongAnswer(\n                  \
    \          f\"Ingredient '{ingredient.title}' was not found in the database, although\
    \ it was in a previously added recipe (title recipe '{r.title}'). This ingredient\
    \ may have been in another recipe that was previously removed.Or you did not update\
    \ the data correctly (PUT).\")\n            sql_query = f\"SELECT title FROM {self.recipe_name_table};\"\
    \n            cursor.execute(sql_query)\n            res = cursor.fetchall()\n\
    \            list_names = []\n            for tup in res:\n                name\
    \ = tup[0]\n                list_names.append(name)\n            for r in list_recipes:\n\
    \                if r.title not in list_names:\n                    con.close()\n\
    \                    raise WrongAnswer(f\"No recipe with the title {r.title} is\
    \ found in the database\")\n        con.close()\n\n\n\n    async def test_post_recipe(self,\
    \ recipe:Recipe_info):\n        try:\n            r = requests.post(self.links[2].format(self.get_url()),\
    \ json=str(recipe))\n        except requests.exceptions.ConnectionError as e:\n\
    \            raise WrongAnswer(self.connection_error.format(e.request.method,\
    \ e.request.url.split('?')[0]))\n        if r.status_code != 200:\n          \
    \  raise WrongAnswer(self.wrong_answers[1].format(self.links[0].format(\"POST\
    \ /\"), r.status_code))\n        content = r.content.decode(\"UTF-8\")\n     \
    \   self.check_post_recipe_respond(content)\n        json_dict = json.loads(content)\n\
    \        self.list_added_recipes.append(Recipe_info_with_id(recipe, int(json_dict['id'])))\n\
    \n    async def test_put_recipe(self, id, recipe, recipe_exists=False):\n    \
    \    url = self.links[3].format(self.get_url(), id)\n        json_recipe = recipe.to_json()\n\
    \        try:\n            r = requests.put(url, json=json_recipe)\n        except\
    \ requests.exceptions.ConnectionError as e:\n            raise WrongAnswer(self.connection_error.format(e.request.method,\
    \ e.request.url.split('?')[0]))\n        if recipe_exists:\n            if r.status_code\
    \ != 204:\n                raise WrongAnswer( self.wrong_answers[18].format(self.links[3].format(\"\
    PUT /\", id), id, r.status_code))\n            for r in self.list_added_recipes:\n\
    \                if r.id == int(id):\n                    self.list_added_recipes.remove(r)\n\
    \                    self.list_added_recipes.append(Recipe_info_with_id(recipe,\
    \ id))\n                    break\n\n        if not recipe_exists:\n         \
    \   if r.status_code != 404:\n                raise WrongAnswer(\n           \
    \         \"GET '/{}' route should return 404 if no recipes with id {} exists\"\
    .format(url, id));\n\n    @dynamic_test(order=-1)\n    def test_1(self):\n   \
    \     ExitHandler.revert_exit()\n        print(\"Test database (structure)\")\n\
    \        asyncio.get_event_loop().run_until_complete(\n            self.test_database_structure())\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=0)\n    def test0(self):\n\
    \        ExitHandler.revert_exit()\n        print(\"Check database data\")\n \
    \       asyncio.get_event_loop().run_until_complete(\n            self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=1)\n    def test1(self):\n\
    \        ExitHandler.revert_exit()\n        print(\"Get recipe by ingredients,\
    \ no recipe added\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_ingredients([self.list_recipes[0]],\
    \ False, False))\n        return CheckResult.correct()\n\n    @dynamic_test(order=2)\n\
    \    def test2(self):\n        ExitHandler.revert_exit()\n        print(\"Add\
    \ recipe\")\n        asyncio.get_event_loop().run_until_complete(self.test_post_recipe(self.list_recipes[0]))\n\
    \        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=3)\n    def test3(self):\n\
    \        ExitHandler.revert_exit()\n        print(\"Get recipe by added recipe\
    \ ingredients\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_ingredients([self.list_recipes[0]],\
    \ True, True))\n        return CheckResult.correct()\n\n    @dynamic_test(order=4)\n\
    \    def test4(self):\n        ExitHandler.revert_exit()\n        print(\"Get\
    \ recipe by invalid recipe ingredients\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_ingredients([self.list_recipes[1]],\
    \ True, False))\n        return CheckResult.correct()\n\n    @dynamic_test(order=5)\n\
    \    def test5(self):\n        ExitHandler.revert_exit()\n        print(\"Add\
    \ second recipe\")\n        asyncio.get_event_loop().run_until_complete(self.test_post_recipe(self.list_recipes[3]))\n\
    \        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=6)\n    def test6(self):\n\
    \        ExitHandler.revert_exit()\n        print(\"Get recipe by second recipe\
    \ ingredients\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_ingredients([self.list_recipes[3]],\
    \ True, True))\n        return CheckResult.correct()\n\n    @dynamic_test(order=7)\n\
    \    def test7(self):\n        ExitHandler.revert_exit()\n        print(\"Get\
    \ recipe by invalid recipe ingredients\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_ingredients([self.list_recipes[4]],\
    \ True, False))\n        return CheckResult.correct()\n\n    @dynamic_test(order=8)\n\
    \    def test8(self):\n        ExitHandler.revert_exit()\n        print(\"Get\
    \ recipe by invalid id\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_id(99))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=9)\n    def test9(self):\n\
    \        ExitHandler.revert_exit()\n        print(\"Get recipe by valid id, from\
    \ added recipe\")\n        asyncio.get_event_loop().run_until_complete(self.test_get_recipe_by_id(self.list_added_recipes[0].id,\
    \ True, self.list_added_recipes[0]))\n        return CheckResult.correct()\n\n\
    \    @dynamic_test(order=10)\n    def test10(self):\n        ExitHandler.revert_exit()\n\
    \        print(\"Get another recipe with valid id, from added recipe\")\n    \
    \    asyncio.get_event_loop().run_until_complete(\n            self.test_get_recipe_by_id(self.list_added_recipes[1].id,\
    \ True, self.list_added_recipes[1]))\n        return CheckResult.correct()\n\n\
    \    @dynamic_test(order=11)\n    def test11(self):\n        ExitHandler.revert_exit()\n\
    \        print(\"Delete recipe with valid id, from added recipes\")\n        asyncio.get_event_loop().run_until_complete(self.test_del_recipe_by_id(self.list_added_recipes[1].id,\
    \ True, self.list_added_recipes[1]))\n        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=12)\n    def\
    \ test12(self):\n        ExitHandler.revert_exit()\n        print(\"Delete recipe,\
    \ with not added recipe id\")\n        asyncio.get_event_loop().run_until_complete(self.test_del_recipe_by_id(99,\
    \ False))\n        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n\n\n    @dynamic_test(order=14)\n   \
    \ def test14(self):\n        print(\"Check put incorrect id\")\n        asyncio.get_event_loop().run_until_complete(self.test_put_recipe(99,\
    \ self.list_recipes[4], False))\n        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    changed_recipe_id = 0\n    new_recipe\
    \ = None\n\n    @dynamic_test(order=15)\n    def test15(self):\n        self.changed_recipe_id\
    \ = self.list_added_recipes[0].id\n        self.new_recipe = self.list_recipes[4]\n\
    \        print(\"Check put correct id and correct recipe\")\n        asyncio.get_event_loop().run_until_complete(self.test_put_recipe(self.list_added_recipes[0].id,\
    \ self.list_recipes[4], True))\n        asyncio.get_event_loop().run_until_complete(self.check_data_base(self.list_added_recipes))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=16)\n    def\
    \ test16(self):\n        ExitHandler.revert_exit()\n        print(\"Add third\
    \ recipe\")\n        asyncio.get_event_loop().run_until_complete(self.test_post_recipe(self.list_recipes[3]))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=17)\n    def\
    \ test17(self):\n        print(\"Check get changed recipe\")\n        asyncio.get_event_loop().run_until_complete(\n\
    \            self.test_get_recipe_by_id(self.changed_recipe_id, True, self.new_recipe))\n\
    \        return CheckResult.correct()\n\n    @dynamic_test(order=18)\n    def\
    \ test18(self):\n        print(\"Check max_directions\")\n        asyncio.get_event_loop().run_until_complete(\n\
    \            self.test_get_recipe_by_ingredients_max_directions(self.list_added_recipes[0],\
    \ len(self.list_added_recipes[0].directions), True))\n        return CheckResult.correct()\n\
    \n    @dynamic_test(order=19)\n    def test19(self):\n        print(\"Check max_directions\"\
    )\n        asyncio.get_event_loop().run_until_complete(\n            self.test_get_recipe_by_ingredients_max_directions(self.list_added_recipes[0],\
    \ len(self.list_added_recipes[0].directions)-1, False))\n        return CheckResult.correct()\n\
    \n    @dynamic_test(order=20)\n    def test20(self):\n        print(\"Get recipes\
    \ by all ingredients from all added recipes\")\n        asyncio.get_event_loop().run_until_complete(\n\
    \            self.test_sorting())\n        return CheckResult.correct()\n\nif\
    \ __name__ == '__main__':\n    try: os.remove(\"recipes.db\")\n    except: pass\n\
    \    FlaskProjectTest().run_tests()\n    try: os.remove(\"recipes.db\")\n    except:\
    \ pass\n"
    learner_created: false
  - name: tests.py
    visible: false
    text: |-
      from test.tests import remove
      
      if __name__ == '__main__':    try: os.remove("recipes.db")    except: pass    FlaskProjectTest().run_tests()    try: os.remove("recipes.db")    except: pass
    learner_created: false
feedback_link: https://hyperskill.org/learn/step/16551#comment
status: Unchecked
record: -1
